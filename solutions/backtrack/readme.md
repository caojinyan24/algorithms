/**
bracket.go
总结:
这个题目一开始想法是做回溯,但是有点生疏
回溯可以看作是一个车轮,从起点开始,每一次的操作会自动推向下一步操作,直到达到操作的重点(结束条件)
也就是说,在一开始需要确定起点和终点,然后以其中的某一步作为切入点,思考怎么做这一步操作,并且推动下一步的操作
回溯问题的结果通常是多个,这些结果中,不同步骤中不同的选项造成了这些不同的结果,所以在思考具体的某一步的时候,需要思考这些不同的选项是怎么形成最后的结果的
其中有个非常关键的地方,也就是为什么称之为回溯的地方:就是对上一个选项做出的操作做回滚

在最初做这道题的时候, 没有考虑到回滚(把上一次添加的字符删除),导致最后产生的结果长度超出预期

又修改了下解法,使用matrix暂存的方式,先得到长度为i-1的组合,i的组合有两种,加(或),迭代获得解

所以说,每一个题目都是独特的,解法就像是数据公式,公式有很多,但题目是活的,需要对公式有灵活的应用,才能应对复杂多变的题目
*/

/**
combination_sum
回溯思想有固定的编程模板,一个切入点是,一个位置,可能会有多种选项,每一次操作是对这个选项的一次尝试.一个位置完成后,继续进行下一个位置的尝试
在具体编码的时候,需要根据实际情况,考虑终止条件,以及循环遍历的条件

官方题解说:对于寻找所有可行性的问题,都可以使用搜索回溯的解法来做

所以怎么解决排列组合中重复的问题:指定结果的index从小到大进行排列
*/

/**
关于golang语法
golang的map和slice在使用之前,需要进行初始化,这些点很小,但会在写代码的时候浪费调试时间
    // type matrixItem []string
    // var matrix =make([][]matrixItem,n+1)
    // for i:=0;i<n+1;i++{
    //     var item=make([]matrixItem,n+1)
    //     matrix[i]=item
    // }
    // matrix[0][0]=[]string{""}
    // matrix[1][0]=[]string{"("}
    // matrix[1][1]=[]string{"()"}
*/

/**
golang 的sort包使用
	// sort.Slice(candidates,func(i, j int) bool {
	// 	return candidates[i]<candidates[j]
	// })
	sort.IntSlice(candidates).Sort()
*/